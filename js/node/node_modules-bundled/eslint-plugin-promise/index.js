module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  rules: {
    'param-names': __webpack_require__(1),
    'always-return': __webpack_require__(2),
    'always-catch': __webpack_require__(3),
    'catch-or-return': __webpack_require__(4),
    'no-native': __webpack_require__(5)
  },
  rulesConfig: {
    'param-names': 1,
    'always-return': 1,
    'always-catch': 1,
    'no-native': 0,
    'catch-or-return': 1
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = function (context) {
  return {
    NewExpression: function (node) {
      if (node.callee.name === 'Promise' && node.arguments.length === 1) {
        var params = node.arguments[0].params

        if (!params || !params.length) { return }

        if (params[0].name !== 'resolve') {
          return context.report(node, 'Promise constructor parameters must be named resolve, reject')
        }

        if (params[1] && params[1].name !== 'reject') {
          return context.report(node, 'Promise constructor parameters must be named resolve, reject')
        }
      }
    }
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

function isFunctionWithBlockStatement (node) {
  if (node.type === 'FunctionExpression') {
    return true
  }
  if (node.type === 'ArrowFunctionExpression') {
    return node.body.type === 'BlockStatement'
  }
  return false
}

function isReturnOrThrowStatement (node) {
  return node.type === 'ReturnStatement' || node.type === 'ThrowStatement'
}

module.exports = function (context) {
  return {
    MemberExpression: function (node) {
      var firstArg, body, lastStatement

      if (node.property.name !== 'then' || node.parent.type !== 'CallExpression') {
        return
      }

      firstArg = node.parent.arguments[0]
      if (!firstArg || !isFunctionWithBlockStatement(firstArg)) {
        return
      }

      body = firstArg.body.body
      lastStatement = body[body.length - 1]
      if (!lastStatement || !isReturnOrThrowStatement(lastStatement)) {
        context.report(node, 'Each then() should return a value or throw')
      }
    }
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (context) {
  return {
    ExpressionStatement: function (node) {
      // hello.then()
      if (node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'MemberExpression' &&
        node.expression.callee.property.name === 'then'
      ) {
        context.report(node, 'You should always catch() a then()')
        return
      }

      // hello.then().then().catch()
      if (node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'MemberExpression' &&
        node.expression.callee.object.type === 'CallExpression' &&
        node.expression.callee.object.callee.type === 'MemberExpression' &&
        node.expression.callee.object.callee.property.name === 'then'
      ) {
        if (node.expression.callee.property.name !== 'catch') {
          context.report(node, 'You should always catch() a then()')
        }
      }
    }
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (context) {
  var options = context.options[0] || {}
  var allowThen = options.allowThen
  var terminationMethod = options.terminationMethod || 'catch'
  var STATIC_METHODS = [
    'all',
    'race',
    'reject',
    'resolve'
  ]
  function isPromise (expression) {
    return ( // hello.then()
      expression.type === 'CallExpression' &&
      expression.callee.type === 'MemberExpression' &&
      expression.callee.property.name === 'then'
    ) || ( // hello.catch()
      expression.type === 'CallExpression' &&
      expression.callee.type === 'MemberExpression' &&
      expression.callee.property.name === 'catch'
    ) || ( // somePromise.ANYTHING()
      expression.type === 'CallExpression' &&
      expression.callee.type === 'MemberExpression' &&
      isPromise(expression.callee.object)
    ) || ( // Promise.STATIC_METHOD()
      expression.type === 'CallExpression' &&
      expression.callee.type === 'MemberExpression' &&
      expression.callee.object.type === 'Identifier' &&
      expression.callee.object.name === 'Promise' &&
      STATIC_METHODS.indexOf(expression.callee.property.name) !== -1
    )
  }
  return {
    ExpressionStatement: function (node) {
      if (!isPromise(node.expression)) {
        return
      }

      // somePromise.then(a, b)
      if (allowThen &&
        node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'MemberExpression' &&
        node.expression.callee.property.name === 'then' &&
        node.expression.arguments.length === 2
      ) {
        return
      }

      // somePromise.catch()
      if (node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'MemberExpression' &&
        node.expression.callee.property.name === terminationMethod
      ) {
        return
      }
      context.report(node, 'Expected ' + terminationMethod + '() or return')
    }
  }
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Borrowed from here:
// https://github.com/colonyamerican/eslint-plugin-cah/issues/3



module.exports = function (context) {
  var MESSAGE = '"{{name}}" is not defined.'

  /**
   * Checks for and reports reassigned constants
   *
   * @param {Scope} scope - an escope Scope object
   * @returns {void}
   * @private
   */
  function isDeclared (scope, ref) {
    return scope.variables.some(function (variable) {
      if (variable.name !== ref.identifier.name) {
        return false
      }

      if (!variable.defs || !variable.defs.length) {
        return false
      }

      return true
    })
  }

  return {
    'Program:exit': function () {
      var scope = context.getScope()

      scope.implicit.left.forEach(function (ref) {
        if (ref.identifier.name !== 'Promise') {
          return
        }

        if (!isDeclared(scope, ref)) {
          context.report(ref.identifier, MESSAGE, { name: ref.identifier.name })
        }
      })
    }
  }
}


/***/ })
/******/ ]);
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  rules: {
    'array-bracket-even-spacing': __webpack_require__(1),
    'computed-property-even-spacing': __webpack_require__(2),
    'object-curly-even-spacing': __webpack_require__(3)
  },
  rulesConfig: {
    'object-curly-even-spacing': 0,
    'array-bracket-even-spacing': 0,
    'computed-property-even-spacing': 0
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside of array brackets.
 * @author Jamund Ferguson
 * @copyright 2015 Jamund Ferguson. All rights reserved.
 * @copyright 2014 Brandyn Bennett. All rights reserved.
 * @copyright 2014 Michael Ficarra. No rights reserved.
 * @copyright 2014 Vignesh Anand. All rights reserved.
 */


// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = function (context) {
  var spaced = context.options[0] === 'always'
  var either = context.options[0] === 'either'

  /**
   * Determines whether an option is set, relative to the spacing option.
   * If spaced is "always", then check whether option is set to false.
   * If spaced is "never", then check whether option is set to true.
   * @param {Object} option - The option to exclude.
   * @returns {boolean} Whether or not the property is excluded.
   */
  function isOptionSet (option) {
    return context.options[1] != null ? context.options[1][option] === !spaced : false
  }

  var options = {
    either: either,
    spaced: spaced,
    singleElementException: isOptionSet('singleValue'),
    objectsInArraysException: isOptionSet('objectsInArrays'),
    arraysInArraysException: isOptionSet('arraysInArrays')
  }

  // --------------------------------------------------------------------------
  // Helpers
  // --------------------------------------------------------------------------

  /**
   * Determines whether two adjacent tokens are have whitespace between them.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not there is space between the tokens.
   */
  function isSpaced (left, right) {
    return left.range[1] < right.range[0]
  }

  /**
   * Determines whether two adjacent tokens are on the same line.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not the tokens are on the same line.
   */
  function isSameLine (left, right) {
    return left.loc.start.line === right.loc.start.line
  }

  /**
   * Reports that there shouldn't be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space after '" + token.value + "'")
  }

  /**
   * Reports that there shouldn't be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space before '" + token.value + "'")
  }

  /**
   * Reports that there should be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required after '" + token.value + "'")
  }

  /**
   * Reports that there should be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required before '" + token.value + "'")
  }

  /**
   * Checks if a start and end brace in a node are spaced evenly
   * and not too long (>1 space)
   * @param node
   * @param start
   * @param end
   * @returns {boolean}
   */
  function isEvenlySpacedAndNotTooLong (node, start, end) {
    var expectedSpace = start[1].range[0] - start[0].range[1]
    var endSpace = end[1].range[0] - end[0].range[1]
    return endSpace === expectedSpace && endSpace <= 1
  }

  /**
   * Validates the spacing around array brackets
   * @param {ASTNode} node - The node we're checking for spacing
   * @returns {void}
   */
  function validateArraySpacing (node) {
    if (node.elements.length === 0) {
      return
    }

    var first = context.getFirstToken(node)
    var second = context.getFirstToken(node, 1)
    var penultimate = context.getLastToken(node, 1)
    var last = context.getLastToken(node)

    var openingBracketMustBeSpaced =
    options.objectsInArraysException && second.value === '{' ||
    options.arraysInArraysException && second.value === '[' ||
    options.singleElementException && node.elements.length === 1
      ? !options.spaced : options.spaced

    var closingBracketMustBeSpaced =
    options.objectsInArraysException && penultimate.value === '}' ||
    options.arraysInArraysException && penultimate.value === ']' ||
    options.singleElementException && node.elements.length === 1
      ? !options.spaced : options.spaced

    // we only care about evenly spaced things
    if (options.either) {
      // newlines at any point means return
      if (!isSameLine(first, last)) {
        return
      }

      // confirm that the object expression/literal is spaced evenly
      if (!isEvenlySpacedAndNotTooLong(node, [first, second], [penultimate, last])) {
        context.report(node, 'Expected consistent spacing')
      }

      return
    }

    if (isSameLine(first, second)) {
      if (openingBracketMustBeSpaced && !isSpaced(first, second)) {
        reportRequiredBeginningSpace(node, first)
      }
      if (!openingBracketMustBeSpaced && isSpaced(first, second)) {
        reportNoBeginningSpace(node, first)
      }
    }

    if (isSameLine(penultimate, last)) {
      if (closingBracketMustBeSpaced && !isSpaced(penultimate, last)) {
        reportRequiredEndingSpace(node, last)
      }
      if (!closingBracketMustBeSpaced && isSpaced(penultimate, last)) {
        reportNoEndingSpace(node, last)
      }
    }
  }

  // --------------------------------------------------------------------------
  // Public
  // --------------------------------------------------------------------------

  return {
    ArrayPattern: validateArraySpacing,
    ArrayExpression: validateArraySpacing
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside computed properties.
 * @author Jamund Ferguson
 * @copyright 2015 Jamund Ferguson. All rights reserved.
 */


// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = function (context) {
  var propertyNameMustBeSpaced = context.options[0] === 'always' // default is "never"
  var propertyNameMustBeEven = context.options[0] === 'even' // default is "never"

  // --------------------------------------------------------------------------
  // Helpers
  // --------------------------------------------------------------------------

  /**
   * Determines whether two adjacent tokens are have whitespace between them.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not there is space between the tokens.
   */
  function isSpaced (left, right) {
    return left.range[1] < right.range[0]
  }

  /**
   * Determines whether two adjacent tokens are on the same line.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not the tokens are on the same line.
   */
  function isSameLine (left, right) {
    return left.loc.start.line === right.loc.start.line
  }

  /**
   * Reports that there shouldn't be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space after '" + token.value + "'")
  }

  /**
   * Reports that there shouldn't be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space before '" + token.value + "'")
  }

  /**
   * Reports that there should be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required after '" + token.value + "'")
  }

  /**
   * Reports that there should be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required before '" + token.value + "'")
  }

  /**
   * Returns a function that checks the spacing of a node on the property name
   * that was passed in.
   * @param {String} propertyName The property on the node to check for spacing
   * @returns {Function} A function that will check spacing on a node
   */
  function checkSpacing (propertyName) {
    return function (node) {
      if (!node.computed) {
        return
      }

      var property = node[propertyName]

      var before = context.getTokenBefore(property)
      var first = context.getFirstToken(property)
      var last = context.getLastToken(property)
      var after = context.getTokenAfter(property)
      var startSpace, endSpace

      if (propertyNameMustBeEven) {
        if (!isSameLine(before, after)) {
          context.report(node, 'Expected "[" and "]" to be on the same line')
          return
        }
        startSpace = first.loc.start.column - before.loc.end.column
        endSpace = after.loc.start.column - last.loc.end.column

        if (startSpace !== endSpace || startSpace > 1) {
          context.report(node, 'Expected 1 or 0 spaces around "[" and "]"')
        }

        return
      }

      if (isSameLine(before, first)) {
        if (propertyNameMustBeSpaced) {
          if (!isSpaced(before, first) && isSameLine(before, first)) {
            reportRequiredBeginningSpace(node, before)
          }
        } else {
          if (isSpaced(before, first)) {
            reportNoBeginningSpace(node, before)
          }
        }
      }

      if (isSameLine(last, after)) {
        if (propertyNameMustBeSpaced) {
          if (!isSpaced(last, after) && isSameLine(last, after)) {
            reportRequiredEndingSpace(node, after)
          }
        } else {
          if (isSpaced(last, after)) {
            reportNoEndingSpace(node, after)
          }
        }
      }
    }
  }

  // --------------------------------------------------------------------------
  // Public
  // --------------------------------------------------------------------------

  return {
    Property: checkSpacing('key'),
    MemberExpression: checkSpacing('property')
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside of object literals.
 * @author Jamund Ferguson
 * @copyright 2014 Brandyn Bennett. All rights reserved.
 * @copyright 2014 Michael Ficarra. No rights reserved.
 * @copyright 2014 Vignesh Anand. All rights reserved.
 * @copyright 2015 Jamund Ferguson. All rights reserved.
 */


// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = function (context) {
  var spaced = context.options[0] === 'always'
  var either = context.options[0] === 'either'

  /**
   * Determines whether an option is set, relative to the spacing option.
   * If spaced is "always", then check whether option is set to false.
   * If spaced is "never", then check whether option is set to true.
   * @param {Object} option - The option to exclude.
   * @returns {boolean} Whether or not the property is excluded.
   */
  function isOptionSet (option) {
    return context.options[1] != null ? context.options[1][option] === !spaced : false
  }

  var options = {
    spaced: spaced,
    either: either,
    arraysInObjectsException: isOptionSet('arraysInObjects'),
    objectsInObjectsException: isOptionSet('objectsInObjects')
  }

  // --------------------------------------------------------------------------
  // Helpers
  // --------------------------------------------------------------------------

  /**
   * Determines whether two adjacent tokens are have whitespace between them.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not there is space between the tokens.
   */
  function isSpaced (left, right) {
    return left.range[1] < right.range[0]
  }

  /**
   * Determines whether two adjacent tokens are on the same line.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not the tokens are on the same line.
   */
  function isSameLine (left, right) {
    return left.loc.start.line === right.loc.start.line
  }

  /**
   * Reports that there shouldn't be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space after '" + token.value + "'")
  }

  /**
   * Reports that there shouldn't be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportNoEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "There should be no space before '" + token.value + "'")
  }

  /**
   * Reports that there should be a space after the first token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredBeginningSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required after '" + token.value + "'")
  }

  /**
   * Reports that there should be a space before the last token
   * @param {ASTNode} node - The node to report in the event of an error.
   * @param {Token} token - The token to use for the report.
   * @returns {void}
   */
  function reportRequiredEndingSpace (node, token) {
    context.report(node, token.loc.start,
      "A space is required before '" + token.value + "'")
  }

  /**
   * Checks if a start and end brace in a node are spaced evenly
   * and not too long (>1 space)
   * @param node
   * @param start
   * @param end
   * @returns {boolean}
   */
  function isEvenlySpacedAndNotTooLong (node, start, end) {
    var expectedSpace = start[1].range[0] - start[0].range[1]
    var endSpace = end[1].range[0] - end[0].range[1]
    return endSpace === expectedSpace && endSpace <= 1
  }

  /**
   * Determines if spacing in curly braces is valid.
   * @param {ASTNode} node The AST node to check.
   * @param {Token} first The first token to check (should be the opening brace)
   * @param {Token} second The second token to check (should be first after the opening brace)
   * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
   * @param {Token} last The last token to check (should be closing brace)
   * @returns {void}
   */
  function validateBraceSpacing (node, first, second, penultimate, last) {
    var closingCurlyBraceMustBeSpaced =
    options.arraysInObjectsException && penultimate.value === ']' ||
    options.objectsInObjectsException && penultimate.value === '}'
      ? !options.spaced : options.spaced

    // we only care about evenly spaced things
    if (options.either) {
      // newlines at any point means return
      if (!isSameLine(first, last)) {
        return
      }

      // confirm that the object expression/literal is spaced evenly
      if (!isEvenlySpacedAndNotTooLong(node, [first, second], [penultimate, last])) {
        context.report(node, 'Expected consistent spacing')
      }

      return
    }

    // { and key are on same line
    if (isSameLine(first, second)) {
      if (options.spaced && !isSpaced(first, second)) {
        reportRequiredBeginningSpace(node, first)
      }
      if (!options.spaced && isSpaced(first, second)) {
        reportNoBeginningSpace(node, first)
      }
    }

    // final key and } ore on the same line
    if (isSameLine(penultimate, last)) {
      if (closingCurlyBraceMustBeSpaced && !isSpaced(penultimate, last)) {
        reportRequiredEndingSpace(node, last)
      }
      if (!closingCurlyBraceMustBeSpaced && isSpaced(penultimate, last)) {
        reportNoEndingSpace(node, last)
      }
    }
  }

  // --------------------------------------------------------------------------
  // Public
  // --------------------------------------------------------------------------

  return {
    // var {x} = y
    ObjectPattern: function (node) {
      if (node.properties.length === 0) {
        return
      }

      var firstSpecifier = node.properties[0]
      var lastSpecifier = node.properties[node.properties.length - 1]

      var first = context.getTokenBefore(firstSpecifier)
      var second = context.getFirstToken(firstSpecifier)
      var penultimate = context.getLastToken(lastSpecifier)
      var last = context.getTokenAfter(lastSpecifier)

      // support trailing commas
      if (last.value === ',') {
        penultimate = last
        last = context.getTokenAfter(last)
      }

      validateBraceSpacing(node, first, second, penultimate, last)
    },

    // import {y} from 'x'
    ImportDeclaration: function (node) {
      var firstSpecifier = node.specifiers[0]
      var lastSpecifier = node.specifiers[node.specifiers.length - 1]

      // don't do anything for namespace or default imports
      if (firstSpecifier && lastSpecifier && firstSpecifier.type === 'ImportSpecifier' && lastSpecifier.type === 'ImportSpecifier') {
        var first = context.getTokenBefore(firstSpecifier)
        var second = context.getFirstToken(firstSpecifier)
        var penultimate = context.getLastToken(lastSpecifier)
        var last = context.getTokenAfter(lastSpecifier)

        validateBraceSpacing(node, first, second, penultimate, last)
      }
    },

    // export {name} from 'yo'
    ExportNamedDeclaration: function (node) {
      if (!node.specifiers.length) {
        return
      }

      var firstSpecifier = node.specifiers[0]
      var lastSpecifier = node.specifiers[node.specifiers.length - 1]
      var first = context.getTokenBefore(firstSpecifier)
      var second = context.getFirstToken(firstSpecifier)
      var penultimate = context.getLastToken(lastSpecifier)
      var last = context.getTokenAfter(lastSpecifier)

      validateBraceSpacing(node, first, second, penultimate, last)
    },

    // var y = {x: 'y'}
    ObjectExpression: function (node) {
      if (node.properties.length === 0) {
        return
      }

      var first = context.getFirstToken(node)
      var second = context.getFirstToken(node, 1)
      var penultimate = context.getLastToken(node, 1)
      var last = context.getLastToken(node)

      validateBraceSpacing(node, first, second, penultimate, last)
    }
  }
}


/***/ })
/******/ ]);